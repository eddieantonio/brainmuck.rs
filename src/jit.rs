//! Entry point for using the JIT-compiler.

use mmap_jit::{as_function, ExecutableRegion, WritableRegion};

/// A CompiledProgram takes an [ExecutableRegion] of code and allows you to run it as a Brainfuck
/// program.
pub struct CompiledProgram {
    code: ExecutableRegion,
}

/// The type of function generated by the compiler, as expressed in function pointer syntax:
type Program = fn(*mut u8, PutChar, GetChar) -> u64;
/// Has the same signature as libc's putchar(3).
type PutChar = fn(u32) -> u32;
/// Has the same signature as libc's getchar(3).
type GetChar = fn() -> u32;

impl CompiledProgram {
    /// Initializes a CompiledProgram from the passed binary machine code.
    pub fn from_binary(binary: &[u8]) -> CompiledProgram {
        let mut mem = WritableRegion::allocate(binary.len()).unwrap();
        (&mut mem[0..binary.len()]).copy_from_slice(&binary);

        CompiledProgram {
            code: mem.into_executable().unwrap(),
        }
    }

    /// Run the program!
    pub fn run(&self, universe: &mut [u8]) {
        let program = unsafe { as_function!(self.code, Program) };

        program(universe.as_mut_ptr(), putchar, getchar);
    }
}

/// Emulates libc's `putchar(3)`
fn putchar(c: u32) -> u32 {
    print!("{}", (c & 0xFF) as u8 as char);
    1
}

/// Emulates libc's `getchar(3)`
fn getchar() -> u32 {
    use std::io::{self, Read};
    let mut one_byte = [0u8];
    io::stdin()
        .read_exact(&mut one_byte)
        .expect("could not read even a single byte!");
    one_byte[0] as u32
}
